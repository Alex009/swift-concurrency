
## Задачи на многопоточность и выделение памяти 

1. сделать пример с race condition - 2 потока, которые должны один делать инкремент, другой декремент, 100 повторений параллельно

    [Решение](example1/race-condition-1.playground/Contents.swift)
    
2. сделать пример как это решается с барьером
    
    [Решение](example2/race-condition-2.playground/Contents.swift)
    
3. сделать пример как это решается с семафором

    [Решение](example3/race-condition-3.playground/Contents.swift)
    
4. сделать пример как это решается с атомиками

    [Решение](example4/race-condition-4.playground/Contents.swift)

5. далее делаем усложненный пример - общий ресурс у нас это массив строк. Изначально он пустой. Нужно запустить 10 потоков, которые будут паралелльно 100 раз делать добавление в массив нового значения, которое высчитывается путём "взял все значения из массива и посчитал их md5 или другой хеш", потом запил это значение в массив

    a. выводить в конце (после работы всех потоков) последнее значение из массива и время работы всей программы
    
    b. делаем 4 примера - без синхронизации, с барьером, с семфором, с атомиками
    
    [Решение без синхронизации](example5/example5a/race-condition-5a.playground/Contents.swift)
    
    [Решение с барьером](example5/example5b/race-condition-5b.playground/Contents.swift)
    
    [Решение с семафором](example5/example5с/race-condition-5с.playground/Contents.swift)
    
    [Решение с атомиками](example5/example5e/race-condition-5e/race-condition-5e/ContentView.swift 
)
    (Не работает)
    
    c. добавляем 5 пример - считаем ровно тоже самое без многопоточки вообще. выводим последнее значение и время
    
    [Решение](example5/example5d/race-condition-5d.playground/Contents.swift)
    
6. привести пример deadlock

    [Решение](example6/deadlock.playground/Contents.swift)

про память:
1. нарисовать понятную схему памяти. показать где там стек, где куча. показать ситуацию с 2 стеками (откуда 2?)

    a. рисуем ситуацию 2 потоков. которые работают с объектом User, у которого есть массив адресов с классом Address
    
    b. показать в каких случаях массив будет в стеке, а в каких в куче
    
    [Решение в Playground с комментариями](example7/memory1.playground/Contents.swift)

## Задача #2 - понять параллелизм и конкурентность

Параллелизм - выполнения N действий в один момент времени. Конкурентность - выполнение N действий последовательно, но по чуть чуть каждое.
Чтобы увидеть на практике разницу сделаем следующую программу. Нужно запустить 100 потоков, каждый из которых содержит одинаковый алгоритм, напрягающий процессор - запускаем цикл от 0 до миллиона, в нём еще такойже цикл, и делаем расчет - значение первого цикла умножаем на значение второго и делим на их сумму. полученное значение плюсуем к локальной переменной потока, которая инициируется вне циклов. после циклов выводим в лог значение.
Когда запустите эту программу вы увидите что появление логов с расчитанным числом (которое одинаковое у всех должно быть) происходит с заметной задержкой и нестабильно. И чем меньше у вас ядер процессора, тем больше придется ждать появление первых результатов.

[Решение](parallelism/Parallelism-1.playground/Contents.swift)

После реализации внесите изменение - вместо запуска всех потоков сразу, передайте данный алгоритм как 100 одинаковых задач в ThreadPool, с количеством потоков равным количеству ядер в вашем процессоре. Запустите программу и увидите что теперь результаты приходят значительно быстрее и чаще, выходят почти одновременно, в количестве равном количеству ядер в цп. И на полное выполнение программы также потратится меньше времени, чем на варианте с 100 потоками. Вывод - CPU bound задачи нужно параллелить только на CPU count потоков.

[Решение с GCD](parallelism/Parallelism-2.playground/Contents.swift)

[Решение с OperationQueue](parallelism/Parallelism-3.playground/Contents.swift)

Теперь замените алгоритм расчетов из потоков на простой вызов Thread.sleep на 3 секунды. И запустите программу в варианте с ThreadPool и без ThreadPool. Разницы времени выполнения практически не будет. Вывод - I/O bound задачи можно параллелить на любое количество потоков. Под I/O может быть не только Thread.sleep, но и чтение/запись консоли, файла, сокета.
